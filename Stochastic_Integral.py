"""
Computation of solution of Itô SDE using Riemann-Itô approximation
"""

import numpy as np
from numpy.random import normal, chisquare
import matplotlib.pyplot as plt

class SDEModel():
    """
    Creates a model for an SDE with a mean µ(X_t,t) and a variance σ(X_t,t)
    NB: this model can describe an SDE integral by setting µ=0 and σ the random variable
    """

    def __init__(self,µ,σ):
        """
        µ and σ are both functions of (X_t,B_t,t) where B_t is the Brownian motion in the differential
        """
        self.µ = µ
        self.σ = σ
        return

    def simul(self,T,N):
        """
        Computes the solution of the stochastic SDE modelled using an uniform discretisation from 0 to T
        NB: it numerically solves an equation with random variables. To see the precision, one must 
        solve it multiple time and see the PDF, trajectories etc. 
        """
        #-----Init------
        dt = T/N
        ts = np.arange(0,T,dt)
        X = np.zeros(N+1)
        B_backward = 0 #Used if B_t is present in µ or σ

        for n,t in enumerate(ts):
            δB = normal(0,np.sqrt(dt)) 
            B_forward = B_backward + δB
            X[n+1] = X[n] + SDE.µ(X[n],B_backward,t)*dt + 2*SDE.σ(X[n],B_backward,t)*δB 
            B_backward = B_forward

        return X
    
    def solve(self,T,N=int(1e3),PDF=True,trajectory=True,nb_simul=int(1e4),nb_trajectory=5,reference_solution=None):
        """
        Solves the SDE by iterating Riemann-Itô method nb_simul times
        T is the final time, N the number of space discretisation 
        PDF is if you want PDF to be plot
        trajectory is if you want trajectories to be plot
        referenced_solution is for comparing to a solution if it is known
        """

        #-----Init-----

        Xs_t = np.array([self.simul(T,N) for _ in range(nb_simul)])

        if PDF:
            fig, ax = plt.subplots()    
            #-----Model of PDF-----
            #Taking the last element of the trajectory (i.e. at time t=T) to study the PDF
            Xs_T = Xs_t[:,-1]
            histogram_Xs_T, bins_Xs_T = histPDF(Xs_T)
            ax.plot(bins_Xs_T,histogram_Xs_T,label='Simulation')

            if reference_solution is not None:
                #-----Reference if solution known-----
                Ys_T = np.array([reference_solution["proba"](T) for _ in range(nb_simul)])
                histogram_Ys_T, bins_Ys_T = histPDF(Ys_T)

                ax.plot(bins_Ys_T,histogram_Ys_T,label='Reference')

            ax.legend()

        if trajectory:
            fig, ax = plt.subplots()    
            indxs = np.random.choice(range(nb_simul),size=nb_trajectory)
            ts = np.linspace(0,T,N+1)
            for indx in indxs:
                X_t = Xs_t[indx,:]
                if reference_solution is not None:
                    Y_t = np.array([reference_solution["traj"](t) for t in ts])
                    ax.plot(ts,Y_t)
                ax.plot(ts,X_t)

        plt.show()

def histPDF(data,nb_bins=30):
    """
    Histogram to show the PDF of the data generated by 
    a random variable
    """
    bins = np.linspace(data.min(),data.max(),nb_bins)
    histogram, bins = np.histogram(data,bins=bins,density=True)
    bin_centers = .5*(bins[1:]+bins[:-1])
    # bin_centers = bin_centers[histogram.nonzero()]
    # histogram = histogram[histogram.nonzero()]

    return histogram, bin_centers
        
if __name__=='__main__':
    """
    Simulating a an SDE for dX_t = B_tdB_t (i.e. X_t = B_t²-t) and compare it with t*χ² - t law  
    """
    PDF = True 
    trajectory = False
    T = 1
    N = 1000
    def µ(X,B,t):   
        return 0
    def σ(X,B,t):
        return B
    SDE = SDEModel(µ,σ)

    def p_ref(t):
        return t*chisquare(1)-t
    
    def traj_ref(t):
        return -t

    reference_solution = {"proba": p_ref, "traj": traj_ref}
    SDE.solve(T=1,reference_solution=reference_solution)